0
This post is part of a new series called ‘The Future of Modern Software” and is brought to you by New Relic . Read the series here . As always, VentureBeat is adamant about maintaining editorial objectivity.
Once upon a time, software was written in a single language, run on a single machine, and pulled data from a single database. Tracking down bugs and software slowdowns meant looking within – the problem existed somewhere in your code, on your server, or in your database. Whatever the issue, a local error log likely held the key.
Nowadays, software is a multilingual conglomerate spread across cloud-based servers pulling data from all corners of the Internet, and troubleshooting your app means looking far and wide in places beyond your control.
The traditional stack consists of an operating system, web server, database management system, and programming language. LAMP , for example, can stand for Linux, Apache, MySQL, and PHP – all familiar bastions of web development.
The new stack, however, can be a collection of cloud-based, software-as-a-service (SaaS) solutions.
On the server end, we may rely on platform-as-a-service (PaaS) offerings such as Heroku or Cloud Foundry , which comprise both the operating system and web-server components. Meanwhile, our code might be a smorgasbord of Ruby on Rails, Node.js, Java, and any number of other languages, while our data might arrive via MySQL and API alike. Then we add on the new realm of backend-as-a-service (BaaS) , which provides mobile functionality such as push notifications, with services like Parse and Kinvey . To further complicate things, even many of these services are themselves built upon similarly abstracted stacks — Heroku, for example, is a PaaS that runs on infrastructure-as-a-service (IaaS) Amazon Web Services . All of this is to say that hunting down the culprit when your app hangs presents problems unforeseen in the age of local error logs.
So, what is the developer to do in the modern age of mobile app development?
When an app performs poorly, the problem may lie in any one of these distributed services or even on the client-side, which brings about its own array of variables, from operating systems to hardware. The answer lies in yet another SaaS solution: application performance management (APM) .
APM services help developers monitor and manage their apps by providing end-to-end visibility. They not only help detect inefficient code but also offer insight into potential problem areas like device compatibility, lagging servers, faulty API calls, or even geographic slow-downs — all in real time. Now, it’s not as if APM were a revolutionary solution to a yet unsolved problem. It has been around since the 90s, but its evolution into a SaaS has allowed it to at least grow alongside the rapidly expanding stack. Cloud computing means APM can handle far more metrics and data sources than previously possible and third-party vendors can create plugins  linking their product to the APM, providing otherwise unavailable metrics.
APM tools have made great strides in providing ways to monitor and manage all parts of the modern stack, and frankly there’s still a lot of potential. The new generation of APM hopes to fulfill the promises of the agile development movement , giving developers the info they need to keep things running smoothly while focusing on the task at hand: constant iteration.”
